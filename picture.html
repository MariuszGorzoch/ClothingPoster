<!DOCTYPE html>
<html lang="pl">
  <head>
    <meta charset="utf-8" />
    <meta content="width=device-width, initial-scale=1.0" name="viewport" />
    <meta content="yes" name="apple-mobile-web-app-capable" />
    <meta content="default" name="apple-mobile-web-app-status-bar-style" />
    <meta content="yes" name="mobile-web-app-capable" />
    <meta content="Clothing Poster" name="apple-mobile-web-app-title" />
    <link href="MoniTTa.jpg" rel="apple-touch-icon" />
    <title>Podgląd zdjęcia produktu</title>
    <link href="https://fonts.googleapis.com" rel="preconnect" />
    <link crossorigin="" href="https://fonts.gstatic.com" rel="preconnect" />
    <link
      href="https://fonts.googleapis.com/css2?family=Manrope:wght@400;500;700;800&display=swap"
      rel="stylesheet"
    />
    <link
      href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined"
      rel="stylesheet"
    />
    <script src="https://cdn.tailwindcss.com?plugins=forms,container-queries"></script>
    <script>
      tailwind.config = {
        darkMode: "class",
        theme: {
          extend: {
            colors: {
              primary: "#1173d4",
              "background-light": "#f6f7f8",
              "background-dark": "#101922",
            },
            fontFamily: {
              display: ["Manrope"],
            },
            borderRadius: {
              DEFAULT: "0.25rem",
              lg: "0.5rem",
              xl: "0.75rem",
              full: "9999px",
            },
          },
        },
      };
    </script>
    <style>
      body {
        min-height: max(884px, 100dvh);
      }
    </style>
  </head>
  <body class="bg-background-light dark:bg-background-dark font-display">
    <div class="flex h-screen flex-col justify-between">
      <div class="flex-grow overflow-y-auto">
        <header
          class="sticky top-0 z-10 bg-background-light px-4 pb-4 pt-6 backdrop-blur-sm dark:bg-background-dark/80"
        >
          <div class="flex items-center justify-between gap-4">
            <h1 class="text-2xl font-bold text-black dark:text-white">
              Zdjęcie produktu
            </h1>
            <button
              aria-label="Zamknij"
              class="flex size-12 items-center justify-center rounded-full bg-black/5 text-black transition hover:bg-black/10 dark:bg-white/10 dark:text-white dark:hover:bg-white/20"
              id="close-picture"
              type="button"
            >
              <span class="material-symbols-outlined text-3xl leading-none">
                close
              </span>
            </button>
          </div>
        </header>
        <main class="px-4 pb-4">
          <div
            aria-live="polite"
            class="mb-4 hidden rounded-lg border px-4 py-3 text-sm"
            id="action-feedback"
            role="status"
          ></div>
          <section
            class="space-y-4"
            id="picture-container"
            role="region"
            aria-label="Podgląd zdjęcia"
          ></section>
        </main>
      </div>
      <footer
        class="sticky bottom-0 border-t border-black/10 bg-background-light backdrop-blur-sm dark:border-white/10 dark:bg-background-dark/80"
      >
        <nav
          aria-label="Dostępne transformacje"
          class="flex h-16 shrink-0 items-center justify-center overflow-x-auto px-4"
        >
          <div
            class="flex flex-nowrap items-center justify-center gap-6"
            id="transformation-buttons"
            role="group"
          ></div>
        </nav>
        <div class="pb-safe"></div>
      </footer>
    </div>
    <script>
      const params = new URLSearchParams(window.location.search);
      const productId = params.get("productId");
      const imageNameParam = params.get("imageName");

      const PRODUCT_ENDPOINT =
        "https://clothingposterappservice-ada8b4eahpfxbrd6.polandcentral-01.azurewebsites.net/products";
      const AI_ENDPOINT =
        "https://clothingposterappservice-ada8b4eahpfxbrd6.polandcentral-01.azurewebsites.net/ai/images/generate";

      const pictureContainer = document.getElementById("picture-container");
      const feedbackElement = document.getElementById("action-feedback");
      const transformationButtonsContainer = document.getElementById(
        "transformation-buttons"
      );
      const closeButton = document.getElementById("close-picture");

      const transformationCatalog = {
        removeBackground: {
          label: "Usuń tło",
          dependsOnStep: null,
          image: null,
          blob: null,
          prompt:
            "Remove the background from the provided image. Return only the subject on a clean, white background. Do not add any text or watermark. Ensure the entire subject is visible.",
        },
        placeOnMannequin: {
          label: "Manekin",
          dependsOnStep: "removeBackground",
          image: null,
          blob: null,
          prompt:
            "Place the provided product image (with background already removed) onto a neutral mannequin. Ensure the clothing fits the mannequin naturally and proportionally — no warping or stretching. The garment should appear as if it’s actually being worn by the mannequin. Adjust scale and alignment so the product sits correctly on the body (shoulders, waist, and hem aligned properly). Maintain the original shape, cut, and proportions of the garment. Do not crop, squeeze, or distort. Add natural, soft shadows and highlights to blend the product seamlessly with the mannequin. Keep the mannequin posture upright and symmetrical. Ensure clean edges — no visible background artifacts. Use a pure white or very light neutral background. Do not add logos, watermarks, or extra elements. Keep lighting consistent between the garment and mannequin for a realistic look. Center the final composition, full mannequin in frame. Optional stylistic enhancements: Slight fabric contouring to suggest a realistic drape on the body. Light smoothing around edges to remove cutout harshness. Subtle shadow under hems or sleeves for depth.",
        },
        addOnDoors: {
          label: "Drzwi",
          dependsOnStep: "removeBackground",
          image: null,
          blob: null,
          prompt:
            "Place the provided product image (with background already removed) in front of an elegant door background. Choose a door that complements and enhances the product’s colors, creating a visually appealing and stylish scene. Ensure the product remains the central focus, properly scaled and proportioned, without warping or distortion. Align the product naturally as if it’s displayed or hanging in front of the door. Match the lighting and shadows so the product and background blend seamlessly. Use soft natural shadows under and around the product for realism. The background should be clean, minimal, and color-coordinated to make the product look attractive and desirable to potential buyers. Keep edges sharp and smooth, with no background artifacts. Do not add logos, watermarks, or extra elements. Ensure the composition is well-balanced, centered, and aesthetically pleasing. Maintain a high-resolution, professional appearance suitable for e-commerce display.",
        },
        buyerEffect: {
          label: "Sprzedaz",
          dependsOnStep: "removeBackground",
          image: null,
          blob: null,
          prompt:
            "Place the provided product image (with background already removed) in an elegant, bright, and stylish setting designed to appeal to women aged 30–50. Choose a background and lighting that highlight the product’s color, shape, and texture, making it look premium and desirable. Position the product front and center with perfect proportions — no stretching or warping — and ensure it looks naturally placed in the scene. Use soft, warm lighting to create a welcoming and sophisticated atmosphere. Add subtle shadows and highlights to enhance the product’s contours and make it stand out. The background should be tasteful, modern, and minimalistic, with complementary colors that elevate the product without overpowering it. Ensure clean, smooth edges and a balanced composition. Avoid clutter, logos, or distracting elements. The overall look should feel aspirational, feminine, elegant, and trustworthy — encouraging the viewer to imagine owning and wearing the product",
        },        
      };

      const transformationIconMap = {
        removeBackground: "layers_clear",
        placeOnMannequin: "accessibility",
        addStudioBackground: "photo_camera_back",
      };

      const transformationState = {
        originalImageUrl: "",
        originalImageName: imageNameParam ?? "",
        originalImageBlob: null,
        latestStep: null,
        previewHistory: [],
      };

      const hasRequiredParams = Boolean(productId && imageNameParam);

      let isLoading = false;
      let isTransforming = false;
      let activeTransformationKey = null;

      closeButton?.addEventListener("click", () => {
        const targetUrl = productId
          ? `manage.html?productId=${encodeURIComponent(productId)}`
          : "manage.html";
        window.location.href = targetUrl;
      });

      function showFeedback(message, type = "info") {
        if (!feedbackElement) {
          return;
        }

        const styles = {
          info: "border-primary/40 bg-primary/10 text-primary",
          success: "border-green-500/50 bg-green-500/10 text-green-700 dark:text-green-400",
          error: "border-red-500/40 bg-red-500/10 text-red-600 dark:text-red-400",
        };

        feedbackElement.textContent = message;
        feedbackElement.className = `mb-4 rounded-lg border px-4 py-3 text-sm ${
          styles[type] ?? styles.info
        }`;
      }

      function clearFeedback() {
        if (!feedbackElement) {
          return;
        }
        feedbackElement.textContent = "";
        feedbackElement.className = "mb-4 hidden rounded-lg border px-4 py-3 text-sm";
      }

      function renderPlaceholder(message) {
        document.title = "Podgląd zdjęcia produktu";
        pictureContainer.innerHTML = "";
        const card = document.createElement("div");
        card.className =
          "rounded-lg border border-black/10 bg-white p-4 text-gray-600 shadow-sm dark:border-white/10 dark:bg-background-dark/50 dark:text-gray-300";
        card.textContent = message;
        pictureContainer.appendChild(card);
      }

      function resetTransformations() {
        Object.values(transformationCatalog).forEach((step) => {
          if (step.image && typeof step.image === "string" && step.image.startsWith("blob:")) {
            URL.revokeObjectURL(step.image);
          }
          step.image = null;
          step.blob = null;
        });
        transformationState.latestStep = null;
        activeTransformationKey = null;
        transformationState.previewHistory.forEach((entry) => {
          if (entry?.url && typeof entry.url === "string" && entry.url.startsWith("blob:")) {
            URL.revokeObjectURL(entry.url);
          }
        });
        transformationState.previewHistory = [];
        renderTransformationButtons();
      }

      function addPreviewEntry(entry) {
        const entryId = entry?.id ?? `preview-${Date.now()}-${Math.random().toString(16).slice(2)}`;
        transformationState.previewHistory.push({ ...entry, id: entryId });
        return entryId;
      }

      function renderPreview(scrollTargetId = null) {
        const history = transformationState.previewHistory;

        if (!history.length) {
          renderPlaceholder("Nie znaleziono zdjęcia o podanej nazwie.");
          return;
        }

        const imageName = transformationState.originalImageName ?? "";
        document.title = imageName
          ? `${imageName} – Podgląd zdjęcia`
          : "Podgląd zdjęcia produktu";

        pictureContainer.innerHTML = "";

        const list = document.createElement("div");
        list.className = "space-y-6";

        history.forEach((entry, index) => {
          const layout = document.createElement("article");
          layout.className = "space-y-4";
          layout.dataset.previewEntry = entry.id;

          const captionCard = document.createElement("section");
          captionCard.className =
            "rounded-lg border border-black/10 bg-white p-4 text-sm text-black/70 shadow-sm dark:border-white/10 dark:bg-background-dark/50 dark:text-white/70";
          captionCard.textContent = entry.isOriginal
            ? "Oryginalne zdjęcie"
            : entry.label ?? "Podgląd zdjęcia";

          const imageWrapper = document.createElement("figure");
          imageWrapper.className =
            "relative overflow-hidden rounded-xl border border-black/10 bg-white shadow-sm dark:border-white/10 dark:bg-background-dark/50";

          const img = document.createElement("img");
          img.src = entry.url;
          const descriptionSuffix = entry.label
            ? ` (${entry.label.toLowerCase()})`
            : entry.isOriginal
              ? " (oryginalne)"
              : "";
          img.alt = imageName
            ? `Zdjęcie ${imageName}${descriptionSuffix}`
            : entry.label
              ? `Zdjęcie produktu (${entry.label.toLowerCase()})`
              : "Zdjęcie produktu";
          img.className =
            "h-full max-h-[70vh] w-full object-contain bg-black/5 dark:bg-black/30";
          imageWrapper.appendChild(img);

          if (isTransforming && index === history.length - 1) {
            const overlay = document.createElement("div");
            overlay.className =
              "absolute inset-0 flex items-center justify-center bg-black/40 text-sm font-semibold uppercase tracking-wide text-white";
            overlay.textContent = "Trwa przetwarzanie…";
            imageWrapper.appendChild(overlay);
          }

          layout.appendChild(captionCard);
          layout.appendChild(imageWrapper);
          list.appendChild(layout);
        });

        pictureContainer.appendChild(list);

        if (scrollTargetId) {
          const target = pictureContainer.querySelector(
            `[data-preview-entry="${scrollTargetId}"]`
          );
          if (target) {
            requestAnimationFrame(() => {
              target.scrollIntoView({ behavior: "smooth", block: "start" });
            });
          }
        }
      }

      function extractMatchingImage(images, imageName) {
        if (!Array.isArray(images) || !imageName) {
          return "";
        }

        const target = imageName.trim().toLowerCase();
        if (!target) {
          return "";
        }

        return (
          images.find((url) => {
            if (typeof url !== "string") {
              return false;
            }
            const decodedUrl = decodeURIComponent(url);
            return (
              decodedUrl.toLowerCase().includes(target) ||
              decodedUrl.split("/").pop()?.toLowerCase() === target
            );
          }) ?? ""
        );
      }

      function setLoadingState(loading) {
        isLoading = loading;
        renderTransformationButtons();
      }

      async function downloadImageBlob(imageUrl) {
        if (!imageUrl) {
          throw new Error("Brak adresu źródłowego obrazu.");
        }

        const attemptFetch = async (urlToFetch) => {
          const response = await fetch(urlToFetch, {
            cache: "no-store",
            mode: "cors",
          });

          if (!response.ok) {
            throw new Error("Nie udało się pobrać obrazu źródłowego.");
          }

          return response.blob();
        };

        try {
          return await attemptFetch(imageUrl);
        } catch (error) {
          const isLikelyCorsIssue =
            imageUrl.startsWith("http") &&
            (error instanceof TypeError || error?.message?.includes("Failed to fetch"));

          if (!isLikelyCorsIssue) {
            throw error;
          }

          const proxyUrl = `https://corsproxy.io/?${encodeURIComponent(imageUrl)}`;

          try {
            return await attemptFetch(proxyUrl);
          } catch (proxyError) {
            throw new Error(
              "Nie udało się pobrać obrazu źródłowego. Jeśli strona jest otwierana bezpośrednio z dysku, uruchom ją przez lokalny serwer HTTP lub skontaktuj się z administratorem."
            );
          }
        }
      }

      async function resolveSourceForStep(stepKey) {
        const step = transformationCatalog[stepKey];
        if (!step) {
          return null;
        }

        if (!step.dependsOnStep) {
          if (transformationState.originalImageBlob instanceof Blob) {
            return {
              blob: transformationState.originalImageBlob,
              filename:
                transformationState.originalImageName && transformationState.originalImageName.trim()
                  ? transformationState.originalImageName
                  : "source.png",
            };
          }

          if (!transformationState.originalImageUrl) {
            return null;
          }

          const originalBlob = await downloadImageBlob(
            transformationState.originalImageUrl
          );
          transformationState.originalImageBlob = originalBlob;

          return {
            blob: originalBlob,
            filename:
              transformationState.originalImageName && transformationState.originalImageName.trim()
                ? transformationState.originalImageName
                : "source.png",
          };
        }

        const dependency = transformationCatalog[step.dependsOnStep];
        if (!dependency?.blob) {
          return null;
        }

        return {
          blob: dependency.blob,
          filename: `${step.dependsOnStep}.png`,
        };
      }

      function getAvailableTransformations() {
        return Object.entries(transformationCatalog).filter(([, step]) => {
          if (step.image) {
            return false;
          }
          if (step.dependsOnStep === null) {
            return Boolean(transformationState.originalImageUrl);
          }
          const dependencyImage =
            transformationCatalog[step.dependsOnStep]?.image ?? null;
          return Boolean(dependencyImage);
        });
      }

      function renderTransformationButtons() {
        if (!transformationButtonsContainer) {
          return;
        }

        transformationButtonsContainer.innerHTML = "";

        const appendMessage = (text) => {
          const message = document.createElement("p");
          message.className =
            "max-w-xs text-center text-xs text-black/60 dark:text-white/60";
          message.textContent = text;
          transformationButtonsContainer.appendChild(message);
        };

        if (!hasRequiredParams) {
          appendMessage(
            "Dodaj parametry productId oraz imageName w adresie URL, aby rozpocząć transformacje."
          );
          return;
        }

        if (isLoading) {
          appendMessage("Ładowanie danych produktu…");
          return;
        }

        const available = getAvailableTransformations();

        if (available.length === 0) {
          if (isTransforming) {
            appendMessage("Trwa przetwarzanie obrazu…");
          } else if (!transformationState.originalImageUrl) {
            appendMessage(
              "Załaduj zdjęcie produktu, aby skorzystać z transformacji."
            );
          } else {
            appendMessage(
              "Wszystkie dostępne transformacje zostały zastosowane."
            );
          }
          return;
        }

        available.forEach(([key, step]) => {
          const button = document.createElement("button");
          button.type = "button";
          button.className =
            "flex flex-col items-center gap-1 text-gray-500 transition-colors hover:text-primary focus-visible:outline focus-visible:outline-2 focus-visible:outline-primary disabled:pointer-events-none disabled:opacity-50 dark:text-gray-400 dark:hover:text-primary";
          button.disabled = isTransforming || isLoading;

          const iconSpan = document.createElement("span");
          iconSpan.className = "material-symbols-outlined text-2xl leading-none";
          iconSpan.setAttribute("aria-hidden", "true");
          iconSpan.textContent =
            transformationIconMap[key] ?? "auto_fix_high";
          button.appendChild(iconSpan);

          const labelSpan = document.createElement("span");
          labelSpan.className = "text-xs font-medium";
          labelSpan.textContent =
            isTransforming && activeTransformationKey === key
              ? "Przetwarzanie…"
              : step.label;
          button.appendChild(labelSpan);

          button.addEventListener("click", () => {
            if (!isTransforming && !isLoading) {
              applyTransformation(key);
            }
          });

          transformationButtonsContainer.appendChild(button);
        });
      }

      async function applyTransformation(stepKey) {
        const step = transformationCatalog[stepKey];
        if (!step) {
          return;
        }

        clearFeedback();
        isTransforming = true;
        activeTransformationKey = stepKey;
        renderTransformationButtons();
        renderPreview();

        let source;
        let scrollTargetId = null;

        try {
          source = await resolveSourceForStep(stepKey);
          if (!source?.blob) {
            throw new Error("Brak zdjęcia źródłowego dla wybranej transformacji.");
          }
        } catch (error) {
          console.error(error);
          showFeedback(
            error?.message ?? "Nie udało się przygotować obrazu źródłowego do transformacji.",
            "error"
          );
          isTransforming = false;
          activeTransformationKey = null;
          renderTransformationButtons();
          renderPreview();
          return;
        }

        try {
          showFeedback("Trwa przetwarzanie obrazu…", "info");

          const formData = new FormData();
          formData.append("prompt", step.prompt);
          formData.append(
            "file",
            source.blob,
            source.filename?.trim() ? source.filename : "source.png"
          );

          const response = await fetch(AI_ENDPOINT, {
            method: "POST",
            headers: {
              Accept: "image/png",
            },
            body: formData,
          });

          if (!response.ok) {
            throw new Error("Nie udało się przekształcić obrazu.");
          }

          const resultBlob = await response.blob();
          const objectUrl = URL.createObjectURL(resultBlob);
          step.image = objectUrl;
          step.blob = resultBlob;
          transformationState.latestStep = stepKey;
          const entryId = addPreviewEntry({
            url: objectUrl,
            label: step.label,
            stepKey,
            isOriginal: false,
          });
          showFeedback("Transformacja zakończona pomyślnie.", "success");
          scrollTargetId = entryId;
        } catch (error) {
          console.error(error);
          showFeedback(
            error?.message ?? "Wystąpił problem podczas transformacji obrazu.",
            "error"
          );
        } finally {
          isTransforming = false;
          activeTransformationKey = null;
          renderTransformationButtons();
          renderPreview(scrollTargetId);
        }
      }

      async function fetchProduct() {
        if (!productId) {
          renderPlaceholder("Nie podano identyfikatora produktu.");
          return;
        }

        setLoadingState(true);
        clearFeedback();
        try {
          const response = await fetch(
            `${PRODUCT_ENDPOINT}/${encodeURIComponent(productId)}`
          );
          if (!response.ok) {
            throw new Error("Nie udało się pobrać danych produktu.");
          }
          const product = await response.json();
          const matchedImageUrl = extractMatchingImage(
            product?.Images ?? [],
            imageNameParam ?? ""
          );

          transformationState.originalImageUrl = matchedImageUrl;
          transformationState.originalImageName = imageNameParam ?? "";
          transformationState.originalImageBlob = null;
          resetTransformations();

          if (matchedImageUrl) {
            const entryId = addPreviewEntry({
              url: matchedImageUrl,
              label: null,
              stepKey: null,
              isOriginal: true,
            });
            renderPreview(entryId);
          } else {
            renderPlaceholder(
              "Nie znaleziono zdjęcia o podanej nazwie w bibliotece produktu."
            );
            showFeedback(
              "Nie znaleziono zdjęcia o podanej nazwie w bibliotece produktu.",
              "error"
            );
          }
        } catch (error) {
          console.error(error);
          transformationState.originalImageUrl = "";
          transformationState.latestStep = null;
          transformationState.originalImageBlob = null;
          resetTransformations();
          renderPlaceholder(
            "Wystąpił problem podczas ładowania danych produktu. Spróbuj ponownie później."
          );
          showFeedback(
            error?.message ?? "Nie udało się pobrać szczegółów produktu.",
            "error"
          );
        } finally {
          setLoadingState(false);
        }
      }

      if (!hasRequiredParams) {
        renderPlaceholder(
          "Aby wyświetlić zdjęcie, przekaż parametry productId oraz imageName w adresie URL."
        );
        renderTransformationButtons();
        showFeedback(
          "Brakuje wymaganych parametrów w adresie URL.",
          "error"
        );
      } else {
        renderTransformationButtons();
        fetchProduct();
      }
    </script>
  </body>
</html>
