<!DOCTYPE html>
<html lang="pl">
  <head>
    <meta charset="utf-8" />
    <meta content="width=device-width, initial-scale=1.0" name="viewport" />
    <meta content="yes" name="apple-mobile-web-app-capable" />
    <meta content="default" name="apple-mobile-web-app-status-bar-style" />
    <meta content="yes" name="mobile-web-app-capable" />
    <meta content="yes" name="apple-touch-fullscreen" />
    <meta content="Clothing Poster" name="apple-mobile-web-app-title" />
    <link href="manifest.webmanifest" rel="manifest" />
    <link href="MoniTTa.jpg" rel="apple-touch-icon" />
    <title>Podgląd zdjęcia produktu</title>
    <link href="https://fonts.googleapis.com" rel="preconnect" />
    <link crossorigin="" href="https://fonts.gstatic.com" rel="preconnect" />
    <link
      href="https://fonts.googleapis.com/css2?family=Manrope:wght@400;500;700;800&display=swap"
      rel="stylesheet"
    />
    <link
      href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined"
      rel="stylesheet"
    />
    <script src="https://cdn.tailwindcss.com?plugins=forms,container-queries"></script>
    <script defer src="pwa.js"></script>
    <link href="layout.css" rel="stylesheet" />
    <script>
      tailwind.config = {
        darkMode: "class",
        theme: {
          extend: {
            colors: {
              primary: "#1173d4",
              "background-light": "#f6f7f8",
              "background-dark": "#101922",
            },
            fontFamily: {
              display: ["Manrope"],
            },
            borderRadius: {
              DEFAULT: "0.25rem",
              lg: "0.5rem",
              xl: "0.75rem",
              full: "9999px",
            },
          },
        },
      };
    </script>
  </head>
  <body class="bg-background-light dark:bg-background-dark font-display">
    <div class="page-shell">
      <div class="page-content">
        <header
          class="sticky top-0 z-10 bg-background-light px-4 pb-4 pt-6 backdrop-blur-sm dark:bg-background-dark/80"
        >
          <div class="flex items-center justify-between gap-4">
            <h1 class="text-2xl font-bold text-black dark:text-white">
              Zdjęcie produktu
            </h1>
            <button
              aria-label="Zamknij"
              class="flex size-12 items-center justify-center rounded-full bg-black/5 text-black transition hover:bg-black/10 dark:bg-white/10 dark:text-white dark:hover:bg-white/20"
              id="close-picture"
              type="button"
            >
              <span class="material-symbols-outlined text-3xl leading-none">
                close
              </span>
            </button>
          </div>
        </header>
        <main class="px-4 pb-4">
          <div
            aria-live="polite"
            class="mb-4 hidden rounded-lg border px-4 py-3 text-sm"
            id="action-feedback"
            role="status"
          ></div>
          <section
            class="space-y-4"
            id="picture-container"
            role="region"
            aria-label="Podgląd zdjęcia"
          ></section>
        </main>
      </div>
      <footer
        class="page-footer z-20 border-t border-black/10 bg-background-light backdrop-blur-sm dark:border-white/10 dark:bg-background-dark/80"
      >
        <nav
          aria-label="Dostępne transformacje"
          class="flex h-16 shrink-0 items-center justify-center overflow-x-auto px-4"
        >
          <div
            class="flex flex-nowrap items-center justify-center gap-6"
            id="transformation-buttons"
            role="group"
          ></div>
        </nav>
        <div class="page-footer-safe pb-safe"></div>
      </footer>
    </div>
    <script>
      const params = new URLSearchParams(window.location.search);
      const productId = params.get("productId");
      const imageNameParam = params.get("imageName");

      const PRODUCT_ENDPOINT =
        "https://clothingposterappservice-ada8b4eahpfxbrd6.polandcentral-01.azurewebsites.net/products";
      const AI_ENDPOINT =
        "https://clothingposterappservice-ada8b4eahpfxbrd6.polandcentral-01.azurewebsites.net/ai/images/generate";

      const pictureContainer = document.getElementById("picture-container");
      const feedbackElement = document.getElementById("action-feedback");
      const transformationButtonsContainer = document.getElementById(
        "transformation-buttons"
      );
      const closeButton = document.getElementById("close-picture");

      const transformationCatalog = {
        removeBackground: {
          label: "Usuń tło",
          dependsOnStep: null,
          image: null,
          blob: null,
          prompt:
            "Remove the background from the provided image. Return only the subject on a clean, white background. Do not add any text or watermark. Ensure the entire subject is visible.",
        },
        placeOnMannequin: {
          label: "Manekin",
          image: null,
          blob: null,
          prompt:
            "Place the provided product image (with background already removed) onto a neutral mannequin. Ensure the clothing fits the mannequin naturally and proportionally — no warping or stretching. The garment should appear as if it’s actually being worn by the mannequin. Adjust scale and alignment so the product sits correctly on the body (shoulders, waist, and hem aligned properly). Maintain the original shape, cut, and proportions of the garment. Do not crop, squeeze, or distort. Add natural, soft shadows and highlights to blend the product seamlessly with the mannequin. Keep the mannequin posture upright and symmetrical. Ensure clean edges — no visible background artifacts. Use a pure white or very light neutral background. Do not add logos, watermarks, or extra elements. Keep lighting consistent between the garment and mannequin for a realistic look. Center the final composition, full mannequin in frame. Optional stylistic enhancements: Slight fabric contouring to suggest a realistic drape on the body. Light smoothing around edges to remove cutout harshness. Subtle shadow under hems or sleeves for depth.",
        },
        addOnDoors: {
          label: "Drzwi",
          image: null,
          blob: null,
          prompt:
            "Place the provided product image (with background already removed) in front of an elegant door background. Choose a door that complements and enhances the product’s colors, creating a visually appealing and stylish scene. Ensure the product remains the central focus, properly scaled and proportioned, without warping or distortion. Align the product naturally as if it’s displayed or hanging in front of the door. Match the lighting and shadows so the product and background blend seamlessly. Use soft natural shadows under and around the product for realism. The background should be clean, minimal, and color-coordinated to make the product look attractive and desirable to potential buyers. Keep edges sharp and smooth, with no background artifacts. Do not add logos, watermarks, or extra elements. Ensure the composition is well-balanced, centered, and aesthetically pleasing. Maintain a high-resolution, professional appearance suitable for e-commerce display.",
        },
        buyerEffect: {
          label: "Sprzedaz",
          image: null,
          blob: null,
          prompt:
            "Place the provided product image (with background already removed) in an elegant, bright, and stylish setting designed to appeal to women aged 30–50. Choose a background and lighting that highlight the product’s color, shape, and texture, making it look premium and desirable. Position the product front and center with perfect proportions — no stretching or warping — and ensure it looks naturally placed in the scene. Use soft, warm lighting to create a welcoming and sophisticated atmosphere. Add subtle shadows and highlights to enhance the product’s contours and make it stand out. The background should be tasteful, modern, and minimalistic, with complementary colors that elevate the product without overpowering it. Ensure clean, smooth edges and a balanced composition. Avoid clutter, logos, or distracting elements. The overall look should feel aspirational, feminine, elegant, and trustworthy — encouraging the viewer to imagine owning and wearing the product",
        },
      };

      const transformationIconMap = {
        removeBackground: "layers_clear",
        placeOnMannequin: "accessibility",
        addStudioBackground: "photo_camera_back",
      };

      const transformationState = {
        originalImageUrl: "",
        originalImageName: imageNameParam ?? "",
        originalImageBlob: null,
        latestStep: null,
        previewHistory: [],
        selectedPreviewId: null,
      };

      const storedImageSignatures = new Set();
      let derivedFilenameCounter = 0;

      function sanitizeFilenamePart(value, fallback) {
        if (typeof value !== "string") {
          return fallback;
        }

        const normalized = value
          .trim()
          .toLowerCase()
          .replace(/\.[^.]+$/, "")
          .replace(/[^a-z0-9]+/g, "-")
          .replace(/^-+|-+$/g, "");

        return normalized || fallback;
      }

      function buildDerivedFilename(stepKey) {
        const base = sanitizeFilenamePart(
          transformationState.originalImageName ?? "",
          "image"
        );
        const stepPart = sanitizeFilenamePart(stepKey ?? "preview", "preview");

        derivedFilenameCounter += 1;

        return `${base}-${stepPart}-${derivedFilenameCounter}.png`;
      }

      const hasRequiredParams = Boolean(productId && imageNameParam);

      let isLoading = false;
      let isTransforming = false;
      let activeTransformationKey = null;
      let isRotating = false;
      let isSaving = false;

      function getSelectedPreviewEntry() {
        const selectedId = transformationState.selectedPreviewId;
        if (!selectedId) {
          return null;
        }

        return (
          transformationState.previewHistory.find((entry) => entry.id === selectedId) ?? null
        );
      }

      function setSelectedPreview(previewId) {
        if (transformationState.selectedPreviewId === previewId) {
          return;
        }

        transformationState.selectedPreviewId = previewId ?? null;
        renderPreview();
        renderTransformationButtons();
      }

      function getImageSignature(source) {
        if (!source || typeof source !== "string") {
          return "";
        }

        try {
          const decoded = decodeURIComponent(source);
          const segments = decoded.split(/[/\\]/);
          const lastSegment = segments.pop();
          const normalizedSegment = (lastSegment ?? decoded)
            .split("?")[0]
            .split("#")[0];
          return normalizedSegment.toLowerCase();
        } catch (error) {
          return source.toLowerCase();
        }
      }

      function updateEntrySignature(entry) {
        if (!entry) {
          return "";
        }

        const signatureSource =
          (typeof entry.filename === "string" && entry.filename.trim().length > 0
            ? entry.filename
            : typeof entry.url === "string"
              ? entry.url
              : "") ?? "";
        const signature = getImageSignature(signatureSource);
        entry.signature = signature;
        const isStoredInCatalog =
          signature && storedImageSignatures.has(signature);

        entry.isStored = Boolean(
          entry.isOriginal ||
            (typeof entry.isStored === "boolean"
              ? entry.isStored || isStoredInCatalog
              : isStoredInCatalog)
        );

        return signature;
      }

      function markImageAsStored(signature) {
        if (!signature) {
          return;
        }

        storedImageSignatures.add(signature);
        transformationState.previewHistory.forEach((entry) => {
          if (!entry) {
            return;
          }
          const currentSignature =
            entry.signature ?? updateEntrySignature(entry);
          if (currentSignature === signature) {
            entry.isStored = true;
          }
        });
      }

      function loadImageElement(url) {
        return new Promise((resolve, reject) => {
          if (!url) {
            reject(new Error("Brak adresu obrazu do wczytania."));
            return;
          }

          const image = new Image();
          image.crossOrigin = "anonymous";
          image.onload = () => resolve(image);
          image.onerror = () =>
            reject(new Error("Nie udało się wczytać obrazu do obrotu."));
          image.src = url;
        });
      }

      closeButton?.addEventListener("click", () => {
        const targetUrl = productId
          ? `manage.html?productId=${encodeURIComponent(productId)}`
          : "manage.html";
        window.location.href = targetUrl;
      });

      function showFeedback(message, type = "info") {
        if (!feedbackElement) {
          return;
        }

        if (type === "error") {
          feedbackElement.textContent = message;
          feedbackElement.className =
            "mb-4 rounded-lg border border-red-500/40 bg-red-500/10 px-4 py-3 text-sm text-red-600 dark:text-red-400";
          return;
        }

        if (type === "success") {
          feedbackElement.textContent = message;
          feedbackElement.className =
            "mb-4 rounded-lg border border-emerald-500/40 bg-emerald-500/10 px-4 py-3 text-sm text-emerald-600 dark:text-emerald-400";
          return;
        }

        clearFeedback();
      }

      function clearFeedback() {
        if (!feedbackElement) {
          return;
        }
        feedbackElement.textContent = "";
        feedbackElement.className = "mb-4 hidden rounded-lg border px-4 py-3 text-sm";
      }

      function renderPlaceholder(message) {
        document.title = "Podgląd zdjęcia produktu";
        pictureContainer.innerHTML = "";
        const card = document.createElement("div");
        card.className =
          "rounded-lg border border-black/10 bg-white p-4 text-gray-600 shadow-sm dark:border-white/10 dark:bg-background-dark/50 dark:text-gray-300";
        card.textContent = message;
        pictureContainer.appendChild(card);
      }

      function resetTransformations() {
        Object.values(transformationCatalog).forEach((step) => {
          if (step.image && typeof step.image === "string" && step.image.startsWith("blob:")) {
            URL.revokeObjectURL(step.image);
          }
          step.image = null;
          step.blob = null;
        });
        transformationState.latestStep = null;
        activeTransformationKey = null;
        transformationState.previewHistory.forEach((entry) => {
          if (entry?.url && typeof entry.url === "string" && entry.url.startsWith("blob:")) {
            URL.revokeObjectURL(entry.url);
          }
        });
        transformationState.previewHistory = [];
        transformationState.selectedPreviewId = null;
        renderTransformationButtons();
      }

      function addPreviewEntry(entry) {
        const entryId = entry?.id ?? `preview-${Date.now()}-${Math.random().toString(16).slice(2)}`;
        const wasEmpty = transformationState.previewHistory.length === 0;
        const normalizedEntry = {
          ...entry,
          id: entryId,
          blob: entry?.blob ?? null,
        };

        const signature = updateEntrySignature(normalizedEntry);

        if (normalizedEntry.isStored && signature) {
          storedImageSignatures.add(signature);
        }

        transformationState.previewHistory.push(normalizedEntry);

        if (wasEmpty && !transformationState.selectedPreviewId) {
          transformationState.selectedPreviewId = entryId;
        }

        return entryId;
      }

      async function rotateSelectedPreviewClockwise() {
        const selectedEntry = getSelectedPreviewEntry();
        if (!selectedEntry) {
          showFeedback("Wybierz zdjęcie, aby obrócić je o 90°.", "error");
          return;
        }

        try {
          isRotating = true;
          renderTransformationButtons();

          const imageElement = await loadImageElement(selectedEntry.url);
          const width = imageElement.naturalWidth || imageElement.width;
          const height = imageElement.naturalHeight || imageElement.height;

          if (!width || !height) {
            throw new Error("Nie udało się odczytać wymiarów obrazu.");
          }

          const canvas = document.createElement("canvas");
          canvas.width = height;
          canvas.height = width;

          const context = canvas.getContext("2d");
          if (!context) {
            throw new Error("Brak wsparcia dla elementu canvas w tej przeglądarce.");
          }

          context.translate(height, 0);
          context.rotate(Math.PI / 2);
          context.drawImage(imageElement, 0, 0);

          const rotatedBlob = await new Promise((resolve, reject) => {
            canvas.toBlob((blob) => {
              if (blob) {
                resolve(blob);
              } else {
                reject(new Error("Nie udało się utworzyć obróconego obrazu."));
              }
            }, "image/png");
          });

          const objectUrl = URL.createObjectURL(rotatedBlob);

          if (
            selectedEntry.url &&
            typeof selectedEntry.url === "string" &&
            selectedEntry.url.startsWith("blob:") &&
            selectedEntry.url !== objectUrl
          ) {
            URL.revokeObjectURL(selectedEntry.url);
          }

          selectedEntry.url = objectUrl;
          selectedEntry.blob = rotatedBlob;

          const filenameSource = selectedEntry.filename?.trim()
            ? selectedEntry.filename
            : transformationState.originalImageName?.trim()
              ? transformationState.originalImageName
              : "image.png";
          selectedEntry.filename = filenameSource;

          if (selectedEntry.isOriginal) {
            transformationState.originalImageUrl = objectUrl;
            transformationState.originalImageBlob = rotatedBlob;
          }

          updateEntrySignature(selectedEntry);

          if (selectedEntry.stepKey) {
            const step = transformationCatalog[selectedEntry.stepKey];
            if (step) {
              if (
                step.image &&
                typeof step.image === "string" &&
                step.image.startsWith("blob:") &&
                step.image !== objectUrl
              ) {
                URL.revokeObjectURL(step.image);
              }
              step.image = objectUrl;
              step.blob = rotatedBlob;
            }
          }

          renderPreview(selectedEntry.id ?? null);
        } catch (error) {
          console.error(error);
          showFeedback(
            error?.message ?? "Nie udało się obrócić zdjęcia.",
            "error"
          );
        } finally {
          isRotating = false;
          renderTransformationButtons();
        }
      }

      async function saveSelectedPreview() {
        const selectedEntry = getSelectedPreviewEntry();

        if (!selectedEntry) {
          showFeedback("Wybierz zdjęcie, aby je zapisać.", "error");
          return;
        }

        if (!productId) {
          showFeedback("Brakuje identyfikatora produktu.", "error");
          return;
        }

        if (selectedEntry.isOriginal) {
          showFeedback("Oryginalne zdjęcie produktu nie wymaga zapisu.", "error");
          return;
        }

        if (selectedEntry.isStored) {
          showFeedback("To zdjęcie zostało już zapisane w produkcie.", "error");
          return;
        }

        clearFeedback();
        isSaving = true;
        renderTransformationButtons();

        try {
          let blob = selectedEntry.blob instanceof Blob ? selectedEntry.blob : null;

          if (!blob) {
            if (typeof selectedEntry.url === "string" && selectedEntry.url.trim().length > 0) {
              blob = await downloadImageBlob(selectedEntry.url);
              selectedEntry.blob = blob;
            } else {
              throw new Error("Brak danych obrazu do zapisania.");
            }
          }

          const filenameCandidates = [
            selectedEntry.filename,
            transformationState.originalImageName,
            selectedEntry.stepKey ? `${selectedEntry.stepKey}.png` : null,
            "image.png",
          ];

          const filename =
            filenameCandidates.find(
              (name) => typeof name === "string" && name.trim().length > 0
            ) ?? "image.png";

          selectedEntry.filename = filename;

          const formData = new FormData();
          formData.append("file", blob, filename);

          const response = await fetch(
            `https://localhost:7168/products/${encodeURIComponent(productId)}/images/add`,
            {
              method: "POST",
              body: formData,
            }
          );

          if (!response.ok) {
            throw new Error("Nie udało się zapisać zdjęcia produktu.");
          }

          const signature = updateEntrySignature(selectedEntry);
          markImageAsStored(signature);
          showFeedback("Zdjęcie zostało zapisane pomyślnie.", "success");
        } catch (error) {
          console.error(error);
          showFeedback(
            error?.message ?? "Nie udało się zapisać zdjęcia produktu.",
            "error"
          );
        } finally {
          isSaving = false;
          renderTransformationButtons();
        }
      }

      function renderPreview(scrollTargetId = null) {
        const history = transformationState.previewHistory;

        if (!history.length) {
          renderPlaceholder("Nie znaleziono zdjęcia o podanej nazwie.");
          return;
        }

        const imageName = transformationState.originalImageName ?? "";
        document.title = imageName
          ? `${imageName} – Podgląd zdjęcia`
          : "Podgląd zdjęcia produktu";

        pictureContainer.innerHTML = "";

        const list = document.createElement("div");
        list.className = "space-y-6";

        const selectedPreviewId = transformationState.selectedPreviewId;

        history.forEach((entry, index) => {
          const isSelected = entry.id === selectedPreviewId;

          const layout = document.createElement("article");
          layout.className = "space-y-4";
          layout.dataset.previewEntry = entry.id;

          const captionCard = document.createElement("section");
          captionCard.className =
            "rounded-lg border border-black/10 bg-white p-4 text-sm text-black/70 shadow-sm dark:border-white/10 dark:bg-background-dark/50 dark:text-white/70";

          const captionHeader = document.createElement("div");
          captionHeader.className = "flex items-center gap-2";

          const captionText = document.createElement("p");
          captionText.className = "font-medium";
          captionText.textContent = entry.isOriginal
            ? "Oryginalne zdjęcie"
            : entry.label ?? "Podgląd zdjęcia";
          captionHeader.appendChild(captionText);

          captionCard.appendChild(captionHeader);

          const imageWrapper = document.createElement("figure");
          imageWrapper.className = `${
            "relative overflow-hidden rounded-xl border border-black/10 bg-white shadow-sm transition focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-primary dark:border-white/10 dark:bg-background-dark/50"
          }${
            isSelected
              ? " ring-2 ring-primary"
              : " cursor-pointer hover:ring-2 hover:ring-primary/60"
          }`;
          imageWrapper.tabIndex = 0;
          imageWrapper.setAttribute("role", "button");
          imageWrapper.setAttribute("aria-pressed", isSelected ? "true" : "false");

          const img = document.createElement("img");
          img.src = entry.url;
          const descriptionSuffix = entry.label
            ? ` (${entry.label.toLowerCase()})`
            : entry.isOriginal
              ? " (oryginalne)"
              : "";
          img.alt = imageName
            ? `Zdjęcie ${imageName}${descriptionSuffix}`
            : entry.label
              ? `Zdjęcie produktu (${entry.label.toLowerCase()})`
              : "Zdjęcie produktu";
          img.className =
            "h-full max-h-[70vh] w-full object-contain bg-black/5 dark:bg-black/30";
          imageWrapper.appendChild(img);

          if (!isSelected) {
            const handleSelection = () => {
              setSelectedPreview(entry.id);
            };
            imageWrapper.addEventListener("click", handleSelection);
            imageWrapper.addEventListener("keydown", (event) => {
              if (event.key === "Enter" || event.key === " ") {
                event.preventDefault();
                handleSelection();
              }
            });
          }

          if (isTransforming && index === history.length - 1) {
            const overlay = document.createElement("div");
            overlay.className =
              "absolute inset-0 flex items-center justify-center bg-black/40 text-sm font-semibold uppercase tracking-wide text-white";
            overlay.textContent = "Trwa przetwarzanie…";
            imageWrapper.appendChild(overlay);
          }

          layout.appendChild(captionCard);
          layout.appendChild(imageWrapper);
          list.appendChild(layout);
        });

        pictureContainer.appendChild(list);

        if (scrollTargetId) {
          const target = pictureContainer.querySelector(
            `[data-preview-entry="${scrollTargetId}"]`
          );
          if (target) {
            requestAnimationFrame(() => {
              target.scrollIntoView({ behavior: "smooth", block: "start" });
            });
          }
        }
      }

      function extractMatchingImage(images, imageName) {
        if (!Array.isArray(images) || !imageName) {
          return "";
        }

        const target = imageName.trim().toLowerCase();
        if (!target) {
          return "";
        }

        return (
          images.find((url) => {
            if (typeof url !== "string") {
              return false;
            }
            const decodedUrl = decodeURIComponent(url);
            return (
              decodedUrl.toLowerCase().includes(target) ||
              decodedUrl.split("/").pop()?.toLowerCase() === target
            );
          }) ?? ""
        );
      }

      function setLoadingState(loading) {
        isLoading = loading;
        renderTransformationButtons();
      }

      async function downloadImageBlob(imageUrl) {
        if (!imageUrl) {
          throw new Error("Brak adresu źródłowego obrazu.");
        }

        const attemptFetch = async (urlToFetch) => {
          const response = await fetch(urlToFetch, {
            cache: "no-store",
            mode: "cors",
          });

          if (!response.ok) {
            throw new Error("Nie udało się pobrać obrazu źródłowego.");
          }

          return response.blob();
        };

        try {
          return await attemptFetch(imageUrl);
        } catch (error) {
          const isLikelyCorsIssue =
            imageUrl.startsWith("http") &&
            (error instanceof TypeError || error?.message?.includes("Failed to fetch"));

          if (!isLikelyCorsIssue) {
            throw error;
          }

          const proxyUrl = `https://corsproxy.io/?${encodeURIComponent(imageUrl)}`;

          try {
            return await attemptFetch(proxyUrl);
          } catch (proxyError) {
            throw new Error(
              "Nie udało się pobrać obrazu źródłowego. Jeśli strona jest otwierana bezpośrednio z dysku, uruchom ją przez lokalny serwer HTTP lub skontaktuj się z administratorem."
            );
          }
        }
      }

      async function resolveSourceForStep(stepKey) {
        const step = transformationCatalog[stepKey];
        if (!step) {
          return null;
        }

        const selectedEntry = getSelectedPreviewEntry();

        if (!selectedEntry) {
          throw new Error("Wybierz zdjęcie, które ma zostać przekształcone.");
        }

        const resolveFilename = () => {
          const candidates = [
            selectedEntry.filename,
            transformationState.originalImageName,
            stepKey ? `${stepKey}.png` : null,
          ];
          const match = candidates.find(
            (name) => typeof name === "string" && name.trim().length > 0
          );
          return match ?? "source.png";
        };

        if (selectedEntry.isOriginal) {
          if (!(transformationState.originalImageBlob instanceof Blob)) {
            if (!transformationState.originalImageUrl) {
              throw new Error("Brak obrazu źródłowego do przekształcenia.");
            }

            const originalBlob = await downloadImageBlob(
              transformationState.originalImageUrl
            );
            transformationState.originalImageBlob = originalBlob;
          }

          const filename = resolveFilename();
          if (!selectedEntry.filename || !selectedEntry.filename.trim()) {
            selectedEntry.filename = filename;
          }
          selectedEntry.blob = transformationState.originalImageBlob;
          updateEntrySignature(selectedEntry);

          return {
            blob: transformationState.originalImageBlob,
            filename,
          };
        }

        if (selectedEntry.blob instanceof Blob) {
          const filename = resolveFilename();
          if (!selectedEntry.filename || !selectedEntry.filename.trim()) {
            selectedEntry.filename = filename;
          }
          updateEntrySignature(selectedEntry);
          return {
            blob: selectedEntry.blob,
            filename,
          };
        }

        if (selectedEntry.stepKey) {
          const catalogEntry = transformationCatalog[selectedEntry.stepKey];
          if (catalogEntry?.blob instanceof Blob) {
            const filename = resolveFilename();
            if (!selectedEntry.filename || !selectedEntry.filename.trim()) {
              selectedEntry.filename = filename;
            }
            selectedEntry.blob = catalogEntry.blob;
            updateEntrySignature(selectedEntry);
            return {
              blob: catalogEntry.blob,
              filename,
            };
          }
        }

        if (selectedEntry.url) {
          const downloadedBlob = await downloadImageBlob(selectedEntry.url);
          const filename = resolveFilename();
          selectedEntry.blob = downloadedBlob;
          if (!selectedEntry.filename || !selectedEntry.filename.trim()) {
            selectedEntry.filename = filename;
          }
          updateEntrySignature(selectedEntry);

          return {
            blob: downloadedBlob,
            filename,
          };
        }

        throw new Error("Brak obrazu źródłowego do przekształcenia.");
      }

      function getAvailableTransformations() {
        const selectedEntry = getSelectedPreviewEntry();
        const hasOriginalSource =
          typeof transformationState.originalImageUrl === "string" &&
          transformationState.originalImageUrl.trim().length > 0;
        const hasOriginalBlob = transformationState.originalImageBlob instanceof Blob;

        return Object.entries(transformationCatalog).filter(([, step]) => {
          if (step.image) {
            return false;
          }
          if (!selectedEntry) {
            return false;
          }

          if (selectedEntry.isOriginal) {
            return hasOriginalSource || hasOriginalBlob;
          }

          if (selectedEntry.blob instanceof Blob) {
            return true;
          }

          return Boolean(
            typeof selectedEntry.url === "string" &&
              selectedEntry.url.trim().length > 0
          );
        });
      }

      function renderTransformationButtons() {
        if (!transformationButtonsContainer) {
          return;
        }

        transformationButtonsContainer.innerHTML = "";

        const appendMessage = (text) => {
          const message = document.createElement("p");
          message.className =
            "max-w-xs text-center text-xs text-black/60 dark:text-white/60";
          message.textContent = text;
          transformationButtonsContainer.appendChild(message);
        };

        if (!hasRequiredParams) {
          appendMessage(
            "Dodaj parametry productId oraz imageName w adresie URL, aby rozpocząć transformacje."
          );
          return;
        }

        if (isLoading) {
          appendMessage("Ładowanie danych produktu…");
          return;
        }

        const selectedEntry = getSelectedPreviewEntry();
        const hasOriginalSource =
          typeof transformationState.originalImageUrl === "string" &&
          transformationState.originalImageUrl.trim().length > 0;
        const hasOriginalBlob = transformationState.originalImageBlob instanceof Blob;

        if (!selectedEntry) {
          if (transformationState.previewHistory.length > 0) {
            appendMessage(
              "Wybierz zdjęcie, aby zobaczyć dostępne transformacje."
            );
          } else {
            appendMessage(
              "Załaduj zdjęcie produktu, aby skorzystać z transformacji."
            );
          }
          return;
        }

        const available = getAvailableTransformations();
        const isBusy = isTransforming || isLoading || isRotating || isSaving;

        const rotationButton = document.createElement("button");
        rotationButton.type = "button";
        rotationButton.className =
          "flex flex-col items-center gap-1 text-gray-500 transition-colors hover:text-primary focus-visible:outline focus-visible:outline-2 focus-visible:outline-primary disabled:pointer-events-none disabled:opacity-50 dark:text-gray-400 dark:hover:text-primary";
        rotationButton.disabled = isBusy;

        const rotationIcon = document.createElement("span");
        rotationIcon.className = "material-symbols-outlined text-2xl leading-none";
        rotationIcon.setAttribute("aria-hidden", "true");
        rotationIcon.textContent = "rotate_90_degrees_cw";
        rotationButton.appendChild(rotationIcon);

        const rotationLabel = document.createElement("span");
        rotationLabel.className = "text-xs font-medium";
        rotationLabel.textContent = "Obróć";
        rotationButton.appendChild(rotationLabel);

        rotationButton.addEventListener("click", () => {
          if (!isBusy) {
            rotateSelectedPreviewClockwise();
          }
        });

        transformationButtonsContainer.appendChild(rotationButton);

        const canSave = Boolean(
          selectedEntry &&
            !selectedEntry.isOriginal &&
            !selectedEntry.isStored &&
            productId &&
            ((selectedEntry.blob instanceof Blob && selectedEntry.blob.size > 0) ||
              (typeof selectedEntry.url === "string" &&
                selectedEntry.url.trim().length > 0))
        );

        const saveButton = document.createElement("button");
        saveButton.type = "button";
        saveButton.className =
          "flex flex-col items-center gap-1 text-gray-500 transition-colors hover:text-primary focus-visible:outline focus-visible:outline-2 focus-visible:outline-primary disabled:pointer-events-none disabled:opacity-50 dark:text-gray-400 dark:hover:text-primary";
        saveButton.disabled = isBusy || !canSave;

        const saveIcon = document.createElement("span");
        saveIcon.className = "material-symbols-outlined text-2xl leading-none";
        saveIcon.setAttribute("aria-hidden", "true");
        saveIcon.textContent = "save";
        saveButton.appendChild(saveIcon);

        const saveLabel = document.createElement("span");
        saveLabel.className = "text-xs font-medium";
        saveLabel.textContent = "Zachowaj";
        saveButton.appendChild(saveLabel);

        saveButton.addEventListener("click", () => {
          if (!isBusy && canSave) {
            saveSelectedPreview();
          }
        });

        transformationButtonsContainer.appendChild(saveButton);

        if (available.length === 0) {
          if (isTransforming) {
            appendMessage("Trwa przetwarzanie obrazu…");
          } else if (!hasOriginalSource && !hasOriginalBlob) {
            appendMessage(
              "Załaduj zdjęcie produktu, aby skorzystać z transformacji."
            );
          } else {
            appendMessage(
              "Brak dodatkowych transformacji dostępnych dla wybranego zdjęcia. Wybierz inne zdjęcie lub spróbuj ponownie później."
            );
          }
          return;
        }

        available.forEach(([key, step]) => {
          const button = document.createElement("button");
          button.type = "button";
          button.className =
            "flex flex-col items-center gap-1 text-gray-500 transition-colors hover:text-primary focus-visible:outline focus-visible:outline-2 focus-visible:outline-primary disabled:pointer-events-none disabled:opacity-50 dark:text-gray-400 dark:hover:text-primary";
          button.disabled = isBusy;

          const iconSpan = document.createElement("span");
          iconSpan.className = "material-symbols-outlined text-2xl leading-none";
          iconSpan.setAttribute("aria-hidden", "true");
          iconSpan.textContent =
            transformationIconMap[key] ?? "auto_fix_high";
          button.appendChild(iconSpan);

          const labelSpan = document.createElement("span");
          labelSpan.className = "text-xs font-medium";
          labelSpan.textContent = step.label ?? "Transformacja";
          button.appendChild(labelSpan);

          button.addEventListener("click", () => {
            if (!isBusy) {
              applyTransformation(key);
            }
          });

          transformationButtonsContainer.appendChild(button);
        });
      }

      async function applyTransformation(stepKey) {
        const step = transformationCatalog[stepKey];
        if (!step) {
          return;
        }

        clearFeedback();
        isTransforming = true;
        activeTransformationKey = stepKey;
        renderTransformationButtons();
        renderPreview();

        let source;
        let scrollTargetId = null;

        try {
          source = await resolveSourceForStep(stepKey);
          if (!source?.blob) {
            throw new Error("Brak zdjęcia źródłowego dla wybranej transformacji.");
          }
        } catch (error) {
          console.error(error);
          showFeedback(
            error?.message ?? "Nie udało się przygotować obrazu źródłowego do transformacji.",
            "error"
          );
          isTransforming = false;
          activeTransformationKey = null;
          renderTransformationButtons();
          renderPreview();
          return;
        }

        try {
          const formData = new FormData();
          formData.append("prompt", step.prompt);
          formData.append(
            "file",
            source.blob,
            source.filename?.trim() ? source.filename : "source.png"
          );

          const response = await fetch(AI_ENDPOINT, {
            method: "POST",
            headers: {
              Accept: "image/png",
            },
            body: formData,
          });

          if (!response.ok) {
            throw new Error("Nie udało się przekształcić obrazu.");
          }

          const resultBlob = await response.blob();
          const objectUrl = URL.createObjectURL(resultBlob);
          const filename = buildDerivedFilename(stepKey);
          step.image = objectUrl;
          step.blob = resultBlob;
          transformationState.latestStep = stepKey;
          const entryId = addPreviewEntry({
            url: objectUrl,
            label: step.label,
            stepKey,
            isOriginal: false,
            blob: resultBlob,
            filename,
          });
          transformationState.selectedPreviewId = entryId;
          scrollTargetId = entryId;
        } catch (error) {
          console.error(error);
          showFeedback(
            error?.message ?? "Wystąpił problem podczas transformacji obrazu.",
            "error"
          );
        } finally {
          isTransforming = false;
          activeTransformationKey = null;
          renderTransformationButtons();
          renderPreview(scrollTargetId);
        }
      }

      async function fetchProduct() {
        if (!productId) {
          renderPlaceholder("Nie podano identyfikatora produktu.");
          return;
        }

        setLoadingState(true);
        clearFeedback();
        try {
          const response = await fetch(
            `${PRODUCT_ENDPOINT}/${encodeURIComponent(productId)}`
          );
          if (!response.ok) {
            throw new Error("Nie udało się pobrać danych produktu.");
          }
          const product = await response.json();
          storedImageSignatures.clear();
          (product?.Images ?? []).forEach((url) => {
            if (typeof url !== "string") {
              return;
            }
            const signature = getImageSignature(url);
            if (signature) {
              storedImageSignatures.add(signature);
            }
          });
          const matchedImageUrl = extractMatchingImage(
            product?.Images ?? [],
            imageNameParam ?? ""
          );

          transformationState.originalImageUrl = matchedImageUrl;
          transformationState.originalImageName = imageNameParam ?? "";
          transformationState.originalImageBlob = null;
          resetTransformations();

          if (matchedImageUrl) {
            const entryId = addPreviewEntry({
              url: matchedImageUrl,
              label: null,
              stepKey: null,
              isOriginal: true,
              isStored: true,
              filename: transformationState.originalImageName ?? "",
            });
            renderPreview(entryId);
          } else {
            renderPlaceholder(
              "Nie znaleziono zdjęcia o podanej nazwie w bibliotece produktu."
            );
            showFeedback(
              "Nie znaleziono zdjęcia o podanej nazwie w bibliotece produktu.",
              "error"
            );
          }
        } catch (error) {
          console.error(error);
          transformationState.originalImageUrl = "";
          transformationState.latestStep = null;
          transformationState.originalImageBlob = null;
          storedImageSignatures.clear();
          resetTransformations();
          renderPlaceholder(
            "Wystąpił problem podczas ładowania danych produktu. Spróbuj ponownie później."
          );
          showFeedback(
            error?.message ?? "Nie udało się pobrać szczegółów produktu.",
            "error"
          );
        } finally {
          setLoadingState(false);
        }
      }

      if (!hasRequiredParams) {
        renderPlaceholder(
          "Aby wyświetlić zdjęcie, przekaż parametry productId oraz imageName w adresie URL."
        );
        renderTransformationButtons();
        showFeedback(
          "Brakuje wymaganych parametrów w adresie URL.",
          "error"
        );
      } else {
        renderTransformationButtons();
        fetchProduct();
      }
    </script>
  </body>
</html>
